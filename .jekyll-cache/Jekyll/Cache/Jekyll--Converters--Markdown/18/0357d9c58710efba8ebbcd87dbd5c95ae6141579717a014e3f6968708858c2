I"×)<h3 id="generic-programming-and-templates">Generic Programming and Templates</h3>
<p>Generic programming is a style of computer programming in which algorithms are written in terms of types <em>to-be-specified-later</em> that are <em>instantiated</em> when needed for specific types.</p>

<p>C++ offers a particularly powerful mechanism, templates, which allow us to write generic functions and classes. The simple idea is to pass the data type as a parameter so that we donâ€™t need to write the same code for different data types.</p>

<p>For example, we may need ement a <code class="highlighter-rouge">sort()</code> function for a range of data types. Rather than writing and maintaing multiple implementations, we can write one <code class="highlighter-rouge">sort()</code> function and pass the data type.</p>

<h4 id="how-it-works">How it works</h4>
<p>Templates are expanded at compiler time, similar to macros. The compiler does type-checking before template expansion, and then generates a compiled version of the function for each type that the template function is instantiated with. So whilst there is a single copy of the template function in the source code, the compiled code will have many versions.</p>

<h4 id="function-templates">Function Templates</h4>
<p>Here is an example of a basic template function, which calculates the minimum of two different objects (e.g. <code class="highlighter-rouge">int, double, float, ...</code>):</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">min</span> <span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>To call this function, we use <code class="highlighter-rouge">&lt;...&gt;</code> notation:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">min</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">min</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">'a'</span><span class="p">,</span> <span class="sc">'g'</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>
<p>Bear in mind that the above function only works for data types which support the <code class="highlighter-rouge">&lt;</code> operator. This can include user defined types (i.e. classes, structs) as long as the <code class="highlighter-rouge">&lt;</code> has been appropriately overloaded.</p>

<h4 id="class-templates">Class Templates</h4>
<p>Similarly to function templates, we can use class templates when a class defines something which is independent of the data type. This is particularly useful for classes such as Array, LinkedList, Queue, Stack, etc.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Array</span> <span class="p">{</span>
<span class="nl">private:</span>
  <span class="n">T</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="nl">public:</span>
  <span class="n">Array</span><span class="p">(</span><span class="n">T</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">s</span><span class="p">];</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// some code here</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>
<h4 id="template-specialisation">Template Specialisation</h4>
<p>It is possible to create a special behaviour of a template for a particular data type. This is useful in situations where a certain data type needs to be treated differently to most other data types.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">sort</span><span class="p">(</span><span class="n">T</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// code to implement sort for array of type T</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">sort</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">char</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// code to implement sort for chars only</span>
<span class="p">}</span>
</code></pre></div></div>
<p>In the second block above, we have used template specialisation to implement the template function for arrays of <code class="highlighter-rouge">char</code>s.</p>
<h4 id="multi-parameter-templates">Multi-parameter Templates</h4>
<p>Like with normal parameters, it is possible to pass more than one data type as an argumnet to a template. The following example demonstrates this:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="n">T</span> <span class="n">x</span><span class="p">;</span>
  <span class="n">U</span> <span class="n">y</span><span class="p">;</span>
<span class="nl">public:</span>
  <span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Constructor called"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
  <span class="n">A</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">A</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="default-values">Default values</h4>
<p>Like normal parameters, we can specify default arguments to templates. The following demonstrates this:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span> <span class="o">=</span> <span class="kt">char</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">T</span> <span class="n">x</span><span class="p">;</span> 
  <span class="n">U</span> <span class="n">y</span><span class="p">;</span>
  <span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Constructor called"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
  <span class="n">A</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// This calls A&lt;char, char&gt;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="non-type-parameters">Non-type parameters</h4>

<h4 id="difference-to-function-overloading">Difference to function overloading</h4>

:ET